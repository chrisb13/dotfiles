
#CHRIS' paths
snippet  cbd
'/srv/ccrc/data23/z3457920/leeuwincurrent/'
endsnippet 

snippet  cbd2
'/srv/ccrc/data32/z3457920/leeuwincurrent2/'
endsnippet 

snippet  cbd3
'/srv/ccrc/data32/z3457920/leeuwincurrent3/'
endsnippet 

snippet  cbd4
'/srv/ccrc/data42/z3457920/'
endsnippet 

snippet  currentexps
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdeasternboundary01/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdwesternboundary02/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthernIO_01/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_karimata_itf_03/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_makassar_itf_04/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_moluccas_itf_05/output/pandasHDF/cookie_parted/'
endsnippet 

snippet  currentexps_dict
ckd_exps={\
'fwdeasternboundary01':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdeasternboundary01/output/pandasHDF/cookie_parted/',\
'fwdwesternboundary02':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdwesternboundary02/output/pandasHDF/cookie_parted/',\
'fwdnorthernIO_01':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthernIO_01/output/pandasHDF/cookie_parted/',\
'fwdnorthern_karimata_itf_03':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_karimata_itf_03/output/pandasHDF/cookie_parted/',\
'fwdnorthern_makassar_itf_04':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_makassar_itf_04/output/pandasHDF/cookie_parted/',\
'fwdnorthern_moluccas_itf_05':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_moluccas_itf_05/output/pandasHDF/cookie_parted/',\
}
endsnippet 

snippet  newdata
'/srv/ccrc/data42/z3457920/'
endsnippet 

global !p
def complete(t, opts):
	if t:
		opts= [ m[len(t):] for m in opts if m.startswith(t) ]
	if len(opts)==1:
		return opts[0]
	return "(" + '|'.join(opts) + ")"
endglobal

global !p
def split_it(t):
	"function to convert print statements to logging statements"
	split=t.split(',')
	st='lg.info('
	for idx,var in enumerate(split):
		if idx==0:
			if '"' in var or "'" in var:
				var=var[:-1] + ' "'
				st=st+var+" "
			else:
				st=st+"str(" + var+ ")"
		else:
			if '"' in var or "'" in var:
				var=var[:-1] + ' "'
				st=st+"+"+var+" "
			else:
				st=st+"+"+"str(" + var +")"
	st=st+")"
	return st
endglobal


snippet im "Import" b
import $1`!p snip.rv=complete(t[1], ['matplotlib', 'pandas as pd',\
             'numpy as np', 'datetime as dt', 'logging as lg', 'matplotlib.pyplot as plt'])`
endsnippet

snippet fname "current_file_name" b
`!p snip.rv=os.path.basename(fn)`
endsnippet

snippet logit "change print statement to logger" 
`!p snip.rv=split_it(snip.v.text)`
endsnippet

snippet moo "change print statement to logger" b!
`!p snip.rv=snip.v.text`
endsnippet

snippet r
'~/hdrive/repos/cms_analysis/'
endsnippet

snippet sa
'~/hdrive/repos/swissarmy/'
endsnippet

#CHRIS'
snippet log
lg.info("${1:msg}: " + str(${2:non-string}))
endsnippet


snippet timeitcomplicated
#this gets put in a bash script
#see: https://docs.python.org/2/library/timeit.html
#and one of the later answers from here:
#http://stackoverflow.com/questions/8220801/how-to-use-timeit-module

SETUP="
#body python code

def some_function(argument):
	pass
"

# where n is the number of loops (it will self-optimise if left out)
python -m timeit -n 5 -s "$SETUP" "some_function(argument)" 
endsnippet


snippet timeit
start=time.time()
#insert timed code here
finish=time.time()
lg.info("time for ${0:msg}: %s",str(finish-start))
endsnippet

snippet base
os.path.basename(${1:insert_path_to_file})
endsnippet

snippet fout
import contextlib as ctx
with ctx.closing(open(${1:ofol}+${2:'ofile_name.txt'},'w')) as handle:
     handle.write("string to write"+"\n")
endsnippet

snippet collections
import collections
plot_dict=collections.OrderedDict()
endsnippet


snippet parser
import argparse
parser = argparse.ArgumentParser(description='Parser for ${1:msg}.',\
epilog='')
parser.add_argument("${2:arg}",help="mandatory argument $2 is: ${3:msg}")
parser.add_argument("${4:arg}",help="mandatory argument $4 is: ${5:msg}")
parser.add_argument("-${6:shortarg}","--${7:longarg}",help="optional argument \
$7 for ${8:msg}.",action="store")
args=parser.parse_args()
lg.info("$2 is: "+str(args.$2))
lg.info("$4 is: "+str(args.$4))
if args.$2!=None:
	pass
if args.$4!=None:
	pass
if args.$7==None:
	lg.info("$7 was not given.")
else:
	lg.info("$7 is: "+args.$7)
endsnippet

snippet hackit
import subprocess 
path=['/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/',\
	'/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf2/',\
	'/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf3/']
boundingbox=['118 130 -37 -31','120 130 -37 -31']

#with ctx.closing(open('./go.sh','w')) as handle:
for p in path:
	for bb in boundingbox:
		do="python cms_diagnostics.py " + p + " " + "-bndbox '" + bb + "' &"
		print p,bb
		print ''
		print do
		subprocess.call(do,shell=True)

#subprocess.call('chmod +x ./go.sh',shell=True)
endsnippet

snippet updir
def updir(dir_name,num):
    """
    Function that takes a path and returns the next level up

    Parameters
    ----------
    dir_name: path (string)
    num: number of levels to go up

    Returns
    -------

    Example
    --------
    >>> path=\
    >>> '/srv/ccrc/data32/z3457920/leeuwincurrent3/'
    >>> moo=updir(path,1)
    >>> print moo
    >>> In [4]: moo
    >>> Out[4]: '/srv/ccrc/data32/z3457920/'
    """
    import os
    upd=dir_name
    for n in range(num):
        upd=os.path.abspath(os.path.join(upd, os.pardir))
    return upd+'/'
endsnippet

snippet multi_core
def multi_sh(s_name,args_one):
    """function for an embarrasingly parralel job in which we want to use many cores
    
    :s_name: name of script
    :args_one: list containing argument to send to script
    :returns: s_name + '.sh' script.

    Notes
    -------
    

    Example
    --------
    >>> #to call multi_sh() ...
    >>> s_name='cms_diagnostics.py'
    >>> args_one=\
    >>> ["'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdwesternboundary02/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthernIO_01/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_itf_01/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_itf_02/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdeasternboundary01/output/pandasHDF/'"]
    >>> multi_sh(s_name,args_one)

    >>> #to put in script
    >>> import sys
    >>> ifile=sys.argv[1]
    >>> lg.info('Working folder: ' + ifile)
    """
    import contextlib as ctx
    import subprocess 
    f_name=s_name[:-3]+'.sh'
    lg.info("Creating multi-core script for: " + f_name)
    with ctx.closing(open('./' + f_name,'w')) as handle:
        for arg in args_one:
            do="python " + s_name +" " + arg+" &"
            lg.info("Writing: " + do)
            #subprocess.call(do,shell=True)
            handle.write(do+"\n")

    subprocess.call('chmod +x ' + f_name,shell=True)
    return
endsnippet

snippet catch
if ${1:msg}:
	lg.error("${2:msg}: " + str(${3:non-string}))
	sys.exit("Okay, shit went bad, now exit.")
endsnippet


snippet catchg
#error trap for globbing...
if ${1:msg}==[]:
	lg.error("Globbing returned nothing!")
	sys.exit("Okay, shit went bad, now exit.")
endsnippet
		

snippet loopme
for $1 in $2:
    ${VISUAL}
endsnippet

snippet s
str(${VISUAL:object to convert to string})
endsnippet

snippet nfo
lg.info("${VISUAL:object to put in}")
endsnippet

snippet plthack
def ${1:function_name}(output_opt):
    """
	This function ($1) is designed to ${2:function_doc_string}
    """
	${0:code to plot}
    if output_opt=='':
        plt.show()
    else:
        plt.savefig(output_opt+'$1.png',dpi=300)
        #plt.savefig(output_opt+'$1.pdf',format='pdf')
endsnippet

snippet plot
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
ax.set_title('${1:msg}')
ax.set_xlabel('${2:msg}')
ax.set_ylabel('${3:msg}')
#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')
plt.show()
endsnippet

snippet confirm
confirm = raw_input("Please confirm you're happy with the ...")
if confirm=='y':
    #do something!
	pass
elif confirm=='n':
   sys.exit("Quitting b/c you said you weren't happy with the slice.")
else:
   sys.exit("Quitting b/c you didn't answer yes ('y')  or no ('n').")
endsnippet

snippet clobber
#a clobber check here
try:
    os.remove(${1:file_path})
    lg.info("File: " +os.path.basename($1) + " already exists, clobbering!")
except OSError:
    pass 
endsnippet

snippet months
plt.xlim(0.8, 12.2)
labels=['J','F','M','A','M','J','J','A','S','O','N','D']
labels=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']
ax1.set_xlim(0.8, 12.2)
ax1.set_xticklabels(labels)
endsnippet

snippet splot
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
plt.show()
endsnippet

snippet regex
#really handonline regex finder: https://regex101.com/#python
import re
test_string='cordex24REALNONZ500-ERAI01_1d_19890101_19891231_grid_T_2D.nc'
exp = re.search(r'[0-9]{8}_[0-9]{8}', test_string) ; exp=exp.group()
print exp
endsnippet


snippet savefig
fig.savefig('./.png',dpi=300)
fig.savefig('./.pdf',format='pdf')
endsnippet

snippet snsplot
import seaborn as sns
import itertools
#sns.set(style="whitegrid")
sns.axes_style('darkgrid')
#sns.set_style("ticks")
#sns.set_palette("deep", desat=.6)
sns.set_style("darkgrid", {"grid.linewidth": .5, "axes.facecolor": ".9"})
sym=itertools.cycle(['v','o','^','s','D'])
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
ax.plot(foob.index,foob['transport'], linestyle='--',marker=sym.next(),label=cookie)
plt.show()

#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')

## Now add the legend with some customizations.
#legend = ax.legend(loc='upper right', shadow=True)
#
## The frame is matplotlib.patches.Rectangle instance surrounding the legend.
#frame = legend.get_frame()
#frame.set_facecolor('0.90')
endsnippet


snippet snsplotcomplicated
import seaborn as sns
import itertools
#sns.set(style="whitegrid")
sns.axes_style('darkgrid')
#sns.set_style("ticks")
#sns.set_palette("deep", desat=.6)
sns.set_style("darkgrid", {"grid.linewidth": .5, "axes.facecolor": ".9"})
sym=itertools.cycle(['v','o','^','s','D'])
plt.close('all')
fig=plt.figure()
#fig.set_size_inches(20,12.5)
ax1=fig.add_subplot(2, 1,1)
ax2=fig.add_subplot(2, 1,2)

${0:code to plot}
ax1.plot(foob.index,foob['transport'], linestyle='--',marker=sym.next(),label=cookie)

ax2.set_title('Month--crossing location')
ax2.set_xlabel('month')
ax2.set_ylabel('transport')

#note you can specify axis!
sns.barplot(whole_mean.pathway,whole_mean.transport,ax=ax2)
plt.show()


#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')

## Now add the legend with some customizations.
#legend = ax.legend(loc='upper right', shadow=True)
#
## The frame is matplotlib.patches.Rectangle instance surrounding the legend.
#frame = legend.get_frame()
#frame.set_facecolor('0.90')
endsnippet

snippet gridspecplot
from matplotlib import gridspec
import matplotlib.pyplot as plt
#set up for gridspec plot...
plt.close('all')
#width then height
fig=plt.figure(figsize=(20.0,9.0))
#the other option
#fig.set_size_inches(7.5,15.5)

#if you want to use seaborn too...
import seaborn as sns
sns.set(style="whitegrid")
sns.set_style("ticks")
gs = gridspec.GridSpec(5, 2,width_ratios=[5,1],hspace=.225,wspace=0.065)

#contour plot
ax0 = plt.subplot(gs[0,0])
#ax0.set_title('Crossing at 30 S')
ax0.set_ylabel('Transport (Sv)')

ax1 = plt.subplot(gs[0,1])

ax2 = plt.subplot(gs[1,0], sharex=ax0)
ax2.set_title('Subplot title')
ax2.set_ylabel('Transport (Sv)')

# make some labels invisible
plt.setp(ax1.get_yticklabels()+ax1.get_xticklabels()+\
         ax0.get_xticklabels()+\
         ax2.get_yticklabels(),\
                 visible=False)

#turn on tight layout for gridspec, see more options here:
#http://matplotlib.org/users/tight_layout_guide.html
#couldn't actually get this to work... these options: pad=0.4, w_pad=0.5,
#h_pad=1.0
gs.tight_layout(fig)

# sub-panel enumerations
plt.figtext(0.1, 0.92,  'a)',clip_on=False,color='black',size=22)
plt.figtext(0.1, 0.77,  'b)',clip_on=False,color='black',size=22)
plt.show()
endsnippet

# New Class
snippet cl
class ${1:ClassName}(${2:object}):
	"""
	${3:docstring for $1}.

	Parameters
	----------
	$4: 

	Returns
	-------
	
	Notes
	-------
	

	Example
	--------
	>>> 
	>>> 
	"""
	def __init__(self, ${4:arg}):
		${5:super($1, self).__init__()}
		self.$4 = $4
		${0}
endsnippet

# New Function
snippet de
def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	"""
	${3:docstring for $1}.

	Parameters
	----------
	$4: 

	Returns
	-------
	
	Notes
	-------
	

	Example
	--------
	>>> 
	>>> 
	"""
	${0}
endsnippet

#pandas
snippet savehdf_append
efile = ${1:variable for export path} + ${2:name of exported hdf}+'_table'+ '.h5'
store = pd.HDFStore(efile,complevel=9, complib='blosc')
store.append('DF',DF,data_columns = ${3:list of columns that will be data columns}) #querable columns or dc take more space and are slower
store.close()
endsnippet


snippet savehdf_put
efile = ${1:variable for export path} +\
		${2:name of exported hdf} +\
        '_table'+ '.h5'

#a clobber check here
try:
    os.remove(efile)
    lg.info("HDFStore already existed, clobbering!")
except OSError:
    pass 

#Due to Pandas 'TypeError' had to use put rather than append...
store = pd.HDFStore(efile,complevel=9, complib='blosc')
store.put('$3',${3:name of dataframe})
store.close()
endsnippet

snippet toypanda
import itertools
import pandas as pd
import numpy as np
def expand_grid(data_dict):
    rows = itertools.product(*data_dict.values())
    return pd.DataFrame.from_records(rows, columns=data_dict.keys())


df = expand_grid(
    {'height': [60, 70],
     'weight': [100, 140, 180],
     'sex': ['Male', 'Female']}
    )

df2 = pd.DataFrame(
        {u'stratifying_var': np.random.uniform(0, 100, 20),
         u'price': np.random.normal(100, 5, 20)}
    )
endsnippet


snippet toypandamerge
#Doing join/merge of DF's that are different sizes...
one=pd.DataFrame({"year":[1992,2003,2014],"blah":[231,1232,1212],"parnum":[1,2,3]})
two=pd.DataFrame({"seconds":[20,40,20,60,60,60],"garbage":[204,430,240,-60,604,603],"parnum":[1,1,2,3,3,3]})
two.merge(one[['year','parnum']],on='parnum')
endsnippet

snippet loadtoy
import pandas as pd
import numpy as np
file='/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/'
file='/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/'
file='/home/z3457920/hdrive/repos/cms_analysis/fwdcore_toyhdf/traj_file_05_table.h5'
dataframe=pd.HDFStore(file)
df=dataframe.select('DF')
endsnippet


snippet toymaskedarray 
import numpy as np
mask=[[False,True,False], \
     [False,False,False], \
     [False,False,True], \
     [False,True,False]]
old=np.ma.MaskedArray(np.random.rand(4,3),mask=mask)
new=np.ma.MaskedArray(np.random.rand(4,3),mask=mask)
endsnippet

snippet loadnetcdf
from netCDF4 import Dataset
file='/path/to/netcdf4/file.nc'
ifile=Dataset(file, 'r')
varone=ifile.variables['']
endsnippet


snippet loadhdf
import pandas as pd
file='path/to/hdfstore.h5'
dataframe=pd.HDFStore(file)
df=dataframe.select('DF')
endsnippet


snippet glob
import glob
ifiles=sorted(glob.glob(${1:varpath to glob} + ${2:string to glob} ))
assert(ifiles!=[]),"glob didn't find anything!"
endsnippet

snippet pd
import pandas as pd
endsnippet

snippet rounddf
slice['latitude']=np.round(slice['latitude']/.1)*.1     
endsnippet


snippet pickle
#Save a dictionary into a pickle file.
import pickle
favorite_color = { "lion": "yellow", "kitty": "red" }
pickle.dump( favorite_color, open( "save.p", "wb" ) )

# Load the dictionary back from the pickle file.
favorite_color = pickle.load( open( "save.p", "rb" ) )
# favorite_color is now { "lion": "yellow", "kitty": "red" }
endsnippet

snippet sor
ifiles=sorted(glob.glob(path + '*' ))
endsnippet

#quick import commands
snippet plt
import matplotlib.pyplot as plt
endsnippet

snippet np
import numpy as np
endsnippet

#matplotlib
snippet title
ax.set_title('${1:Title}')
endsnippet

snippet xlab
ax.set_xlabel('${1:xlabel}')
endsnippet

snippet ylab
ax.set_xlabel('${1:ylabel}')
endsnippet

snippet xlim
#ax.set_xlim([-1,5])
endsnippet

snippet ylim
#ax.set_ylim([-10,10])
endsnippet

snippet lines
#these use axes coords!
#ax.axhline(y=0.2,xmin=0,xmax=3,c="blue",linewidth=3,zorder=0)
#ax.axhline(y=-8,xmin=0,xmax=0.5,c="blue",linewidth=3)
#ax.axhline(y=-5, xmin=0, xmax=0.5,c="red",linewidth=3,zorder=0)

# horizontal line
ax.hlines(y=-8.5, xmin=90, xmax=114,linewidth=3, color='red', zorder=1)
ax.hlines(y=-8.5, xmin=114, xmax=140,linewidth=3, color='purple', zorder=1)

# vertical line
ax.vlines(x=90.1, ymin=-49, ymax=-8.5,linewidth=3, color='blue', zorder=1)
ax.vlines(x=142.5, ymin=-11, ymax=-9,linewidth=3, color='sienna', zorder=1)
endsnippet

snippet globalsavefig
##file for importing global settings
from p_global_settings import *

if plottype=='png':
	plt.savefig(global_plot_outfol+'${1:output_file_name}.png',dpi=300)
elif plottype=='pdf':
	plt.savefig(global_plot_outfol+'$1.pdf')
elif plottype=='both':
	plt.savefig(global_plot_outfol+'$1.png',dpi=300)
	plt.savefig(global_plot_outfol+'$1.pdf')
endsnippet


#stolen from:
#http://bazaar.launchpad.net/~sirver/ultisnips/trunk/view/head:/UltiSnips/python.snippets
###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
# encoding: utf-8
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == '__main__':
	${1:main()}$0
endsnippet


##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2

def get_args(arglist):
    args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
    args = [arg for arg in args if arg and arg != "self"]

    return args


def get_style(snip):
    style = snip.opt("g:ultisnips_python_style", "normal")

    if    style == "doxygen": return DOXYGEN
    else: return NORMAL


def format_arg(arg, style):
    if style == DOXYGEN:
        return "@param %s @todo" % arg
    elif style == NORMAL:
        return ":%s: @todo" % arg


def format_return(style):
    if style == DOXYGEN:
        return "@return: @todo"
    elif style == NORMAL:
        return ":returns: @todo"


def write_docstring_args(args, snip):
    if not args:
        snip.rv += ' """'
        return

    snip += ""

    style = get_style(snip)

    for arg in args:
        snip += format_arg(arg, style)


def write_init_body(args, parents, snip):
    parents = [p.strip() for p in parents.split(",")]
    parents = [p for p in parents if p != 'object']

    for p in parents:
        snip += p + ".__init__(self)"

    if parents:
        snip += ""

    for arg in args:
        snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
    args = ['"%s"' % arg for arg in args]
    snip += '__slots__ = (%s,)' % ', '.join(args)

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'


snip += ""
write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""
	`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'

snip += ""
write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}


def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}


def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}


def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}


def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}


def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}


def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

snippet def "function with docstrings" b
def ${1:function}(`!p
if snip.indent:
   snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	"""${4:@todo: Docstring for $1}`!p
snip.rv = ""
snip >> 1

args = get_args(t[2])
if args:
   write_docstring_args(args, snip)

style = get_style(snip)
snip += format_return(style)
snip += '"""' `

	${0:pass}
endsnippet


# doesn't expand when there is a word in front
snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet from "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet


##############
# PROPERTIES #
##############
snippet roprop "Read Only Property" b
@property
def ${1:property}(self):
	${2:return self._$1}$0
endsnippet

snippet rwprop "Read write property" b
def ${1:property}():
	${2/.+/(?0:""")/}${2:The RW property $1}${2/.+/(?0:"""\n		)/}def fget(self):
		return self._$1$0
	def fset(self, value):
		self._$1 = value
	return locals()
$1 = property(**$1())
endsnippet


##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
endsnippet

snippet try "Try / Except / Else" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet try "Try / Except / Finally" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet try "Try / Except / Else / Finally" b
try:
	${1:pass}
except${2: ${3:Exception}, ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


#####################
# Assertions & Tests #
#####################

snippet ae "Assert equal" b
self.assertEqual(${1:first},${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${0:exp})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:expression})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:first},${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:func}${3/.+/, /}${3:arguments})
endsnippet


snippet testcase "pyunit testcase" b
class Test${1:Class}(${2:unittest.TestCase}):
	"""${3:Test case docstring}"""

	def setUp(self):
		${3:pass}

	def tearDown(self):
		${4:pass}

	def test_${5:name}(self):
		${6:pass}
endsnippet

# vim:ft=snippets:
