
#CHRIS' paths
snippet  cbd
'/srv/ccrc/data23/z3457920/leeuwincurrent/'
endsnippet 

snippet  cbd2
'/srv/ccrc/data32/z3457920/leeuwincurrent2/'
endsnippet 

snippet r
'~/hdrive/repos/cms_analysis/'
endsnippet

snippet sa
'~/hdrive/repos/swissarmy/'
endsnippet


#CHRIS'
snippet log
lg.info("${1:msg}: " + str(${2:non-string}))
endsnippet

snippet timeit
start=time.time()
#insert timed code here
finish=time.time()
lg.info("time for ${0:msg}: %s",str(finish-start))
endsnippet

snippet parser
import argparse
parser = argparse.ArgumentParser(description='Parser for ${1:msg}.',\
epilog='')
parser.add_argument("${2:arg}",help="mandatory argument $2 is: ${3:msg}")
parser.add_argument("${4:arg}",help="mandatory argument $4 is: ${5:msg}")
parser.add_argument("-${6:shortarg}","--${7:longarg}",help="optional argument \
$7 for ${8:msg}.",action="store")
args=parser.parse_args()
lg.info("$2 is: "+str(args.$2))
lg.info("$4 is: "+str(args.$4))
if args.$2!=None:
	pass
if args.$4!=None:
	pass
if args.$7==None:
	lg.info("$7 was not given.")
else:
	lg.info("$7 is: "+args.$7)
endsnippet

snippet hackit
import subprocess 
path=['/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/',\
	'/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf2/',\
	'/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf3/']
boundingbox=['118 130 -37 -31','120 130 -37 -31']

#with ctx.closing(open('./go.sh','w')) as handle:
for p in path:
	for bb in boundingbox:
		do="python cms_diagnostics.py " + p + " " + "-bndbox '" + bb + "' &"
		print p,bb
		print ''
		print do
		subprocess.call(do,shell=True)

#subprocess.call('chmod +x ./go.sh',shell=True)
endsnippet

snippet catch
if ${1:msg}:
	lg.error("${2:msg}: " + str(${3:non-string}))
	sys.exit("Okay, shit went bad, now exit.")
endsnippet
		

snippet loopme
for $1 in $2:
    ${VISUAL}
endsnippet

snippet s
str(${VISUAL})+
endsnippet

snippet plot
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
ax.set_title('${1:msg}')
ax.set_xlabel('${2:msg}')
ax.set_ylabel('${3:msg}')
#fig.savefig('./.png',dpi=300)
plt.show()
endsnippet


snippet splot
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
plt.show()
endsnippet


snippet snsplot


import seaborn as sns
import itertools
#sns.set(style="whitegrid")
sns.axes_style('darkgrid')
#sns.set_style("ticks")
#sns.set_palette("deep", desat=.6)
sns.set_style("darkgrid", {"grid.linewidth": .5, "axes.facecolor": ".9"})
sym=itertools.cycle(['v','o','^','s','D'])
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
ax.plot(foob.index,foob['transport'], linestyle='--',marker=sym.next(),label=cookie)
plt.show()
endsnippet


# New Class
snippet cl
class ${1:ClassName}(${2:object}):
	"""
	${3:docstring for $1}.

	Parameters
	----------
	$4: 

	Returns
	-------
	
	Notes
	-------
	

	Example
	--------
	>>> 
	>>> 
	"""
	def __init__(self, ${4:arg}):
		${5:super($1, self).__init__()}
		self.$4 = $4
		${0}
endsnippet

# New Function
snippet de
def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	"""
	${3:docstring for $1}.

	Parameters
	----------
	$4: 

	Returns
	-------
	
	Notes
	-------
	

	Example
	--------
	>>> 
	>>> 
	"""
	${0}
endsnippet

snippet pdhdf
efile = ${1:variable for export path} + ${2:name of exported hdf}+'_table'+ '.h5'
store = pd.HDFStore(efile,complevel=9, complib='blosc')
store.append('DF',DF,data_columns = ${3:list of columns that will be data columns}) #querable columns or dc take more space and are slower
store.close()
endsnippet

snippet toypanda
import itertools
import pandas as pd
import numpy as np
def expand_grid(data_dict):
    rows = itertools.product(*data_dict.values())
    return pd.DataFrame.from_records(rows, columns=data_dict.keys())


df = expand_grid(
    {'height': [60, 70],
     'weight': [100, 140, 180],
     'sex': ['Male', 'Female']}
    )

df2 = pd.DataFrame(
        {u'stratifying_var': np.random.uniform(0, 100, 20),
         u'price': np.random.normal(100, 5, 20)}
    )

endsnippet

#stolen from:
#http://bazaar.launchpad.net/~sirver/ultisnips/trunk/view/head:/UltiSnips/python.snippets
###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
# encoding: utf-8
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == '__main__':
	${1:main()}$0
endsnippet


##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2

def get_args(arglist):
    args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
    args = [arg for arg in args if arg and arg != "self"]

    return args


def get_style(snip):
    style = snip.opt("g:ultisnips_python_style", "normal")

    if    style == "doxygen": return DOXYGEN
    else: return NORMAL


def format_arg(arg, style):
    if style == DOXYGEN:
        return "@param %s @todo" % arg
    elif style == NORMAL:
        return ":%s: @todo" % arg


def format_return(style):
    if style == DOXYGEN:
        return "@return: @todo"
    elif style == NORMAL:
        return ":returns: @todo"


def write_docstring_args(args, snip):
    if not args:
        snip.rv += ' """'
        return

    snip += ""

    style = get_style(snip)

    for arg in args:
        snip += format_arg(arg, style)


def write_init_body(args, parents, snip):
    parents = [p.strip() for p in parents.split(",")]
    parents = [p for p in parents if p != 'object']

    for p in parents:
        snip += p + ".__init__(self)"

    if parents:
        snip += ""

    for arg in args:
        snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
    args = ['"%s"' % arg for arg in args]
    snip += '__slots__ = (%s,)' % ', '.join(args)

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'


snip += ""
write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""
	`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'

snip += ""
write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}


def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}


def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}


def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}


def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}


def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}


def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

snippet def "function with docstrings" b
def ${1:function}(`!p
if snip.indent:
   snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	"""${4:@todo: Docstring for $1}`!p
snip.rv = ""
snip >> 1

args = get_args(t[2])
if args:
   write_docstring_args(args, snip)

style = get_style(snip)
snip += format_return(style)
snip += '"""' `

	${0:pass}
endsnippet


# doesn't expand when there is a word in front
snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet from "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet


##############
# PROPERTIES #
##############
snippet roprop "Read Only Property" b
@property
def ${1:property}(self):
	${2:return self._$1}$0
endsnippet

snippet rwprop "Read write property" b
def ${1:property}():
	${2/.+/(?0:""")/}${2:The RW property $1}${2/.+/(?0:"""\n		)/}def fget(self):
		return self._$1$0
	def fset(self, value):
		self._$1 = value
	return locals()
$1 = property(**$1())
endsnippet


##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
endsnippet

snippet try "Try / Except / Else" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet try "Try / Except / Finally" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet try "Try / Except / Else / Finally" b
try:
	${1:pass}
except${2: ${3:Exception}, ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


#####################
# Assertions & Tests #
#####################

snippet ae "Assert equal" b
self.assertEqual(${1:first},${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${0:exp})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:expression})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:first},${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:func}${3/.+/, /}${3:arguments})
endsnippet


snippet testcase "pyunit testcase" b
class Test${1:Class}(${2:unittest.TestCase}):
	"""${3:Test case docstring}"""

	def setUp(self):
		${3:pass}

	def tearDown(self):
		${4:pass}

	def test_${5:name}(self):
		${6:pass}
endsnippet

# vim:ft=snippets:
