snippet header
#   Author: Christopher Bull. 
#   Affiliation: Climate Change Research Centre and ARC Centre of Excellence for Climate System Science.
#                Level 4, Mathews Building
#                University of New South Wales
#                Sydney, NSW, Australia, 2052
#   Contact: z3457920@student.unsw.edu.au
#   www:     christopherbull.com.au
`!p 
import time
snip.rv='#   Date created: '+time.strftime("%a, %d %b %Y %H:%M:%S")
`
`!p 
import socket
snip.rv='#   Machine created on: '+socket.gethostname()
`
#

"""
${1:Doc string for script}
"""
import sys,os
sys.path.insert(1,os.path.expanduser('~/hdrive/repos/cms_analysis/'))
from cb2logger import *

if __name__ == "__main__": 
    LogStart('',fout=False)
	${0:#put useful code here!}

    lg.info('')
    localtime = time.asctime( time.localtime(time.time()) )
    lg.info("Local current time : "+ str(localtime))
    lg.info('SCRIPT ended')
endsnippet 

snippet mkheadlogger
`!p
writeme=\
"""
#python logging
import logging as lg
import time
import subprocess
import sys
import os

class LogStart(object):
   "class that sets up a logger"
   def __init__(self, fname,fout=False,level='debug'):
       if level=='debug':
           lvl=lg.DEBUG
       elif level=='info':
           lvl=lg.INFO
       elif level=='warning':
           lvl=lg.WARNING
       elif level=='error':
           lvl=lg.ERROR
       else: 
           raise Exception('You passed a bad logging level')

       if fout:
          lg.basicConfig(filename=fname,filemode='w',\
                  format='%(name)s - %(levelname)s - %(message)s'\
                  , level=lvl) #where filemode clobbers file
       else:
          lg.basicConfig(format='%(name)s - %(levelname)s - %(message)s',\
                  level=lvl)

       lg.info('')
       lg.info('SCRIPT started')
       lg.info('Logging level is: ' + level)
       localtime = time.asctime( time.localtime(time.time()) )
       #found from (see limitations):
       #http://stackoverflow.com/questions/7871319/how-to-know-who-is-importing-me-in-python
       #lg.info("Path for script is : "+os.path.dirname(os.path.realpath(__name__)) )
       lg.info("Script name is : "+ str(sys.argv[0]))

       lg.info("Local current time : "+ str(localtime))

       #lg.info("Machine run on : "+ os.getenv('HOSTNAME'))
       if hasattr(sys, 'real_prefix'):
           lg.info("We are running inside a venv.")
       else:
           lg.info("We are not running inside a venv.")
           return

       lg.info("")
       command=subprocess.Popen(['pip','freeze'],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
       pipout, piperr = command.communicate()
       lg.info("---Pip freeze (including system-wide) START...--- ")
       for pkg in pipout.splitlines():
           lg.info(pkg)
       lg.info("---Pip freeze (including system-wide) END.---")
       lg.info("")
"""
import contextlib as ctx
with ctx.closing(open('./cb2logger.py','w')) as handle:
     handle.write(writeme+"\n")
`
#   Author: Christopher Bull. 
#   Affiliation: Climate Change Research Centre and ARC Centre of Excellence for Climate System Science.
#                Level 4, Mathews Building
#                University of New South Wales
#                Sydney, NSW, Australia, 2052
#   Contact: z3457920@student.unsw.edu.au
#   www:     christopherbull.com.au
`!p 
import time
snip.rv='#   Date created: '+time.strftime("%a, %d %b %Y %H:%M:%S")
`
`!p 
import socket
snip.rv='#   Machine created on: '+socket.gethostname()
`
#

"""
${1:Doc string for script}
"""
from cb2logger import *

if __name__ == "__main__": 
    LogStart('',fout=False)
	${0:#put useful code here!}

    lg.info('')
    localtime = time.asctime( time.localtime(time.time()) )
    lg.info("Local current time : "+ str(localtime))
    lg.info('SCRIPT ended')
endsnippet


#CHRIS' paths
snippet  cbd
'/srv/ccrc/data23/z3457920/leeuwincurrent/'
endsnippet 

snippet  cbd2
'/srv/ccrc/data32/z3457920/leeuwincurrent2/'
endsnippet 

snippet  cbd3
'/srv/ccrc/data32/z3457920/leeuwincurrent3/'
endsnippet 

snippet  cbd4
'/srv/ccrc/data42/z3457920/'
endsnippet 

snippet  currentexps
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdeasternboundary01/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdwesternboundary02/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthernIO_01/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_karimata_itf_03/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_makassar_itf_04/output/pandasHDF/cookie_parted/'
'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_moluccas_itf_05/output/pandasHDF/cookie_parted/'
endsnippet 

snippet  currentexps_dict
ckd_exps={\
'fwdeasternboundary01':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdeasternboundary01/output/pandasHDF/cookie_parted/',\
'fwdwesternboundary02':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdwesternboundary02/output/pandasHDF/cookie_parted/',\
'fwdnorthernIO_01':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthernIO_01/output/pandasHDF/cookie_parted/',\
'fwdnorthern_karimata_itf_03':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_karimata_itf_03/output/pandasHDF/cookie_parted/',\
'fwdnorthern_makassar_itf_04':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_makassar_itf_04/output/pandasHDF/cookie_parted/',\
'fwdnorthern_moluccas_itf_05':'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_moluccas_itf_05/output/pandasHDF/cookie_parted/',\
}
endsnippet 

snippet  newdata
'/srv/ccrc/data42/z3457920/'
endsnippet 

global !p
def complete(t, opts):
	if t:
		opts= [ m[len(t):] for m in opts if m.startswith(t) ]
	if len(opts)==1:
		return opts[0]
	return "(" + '|'.join(opts) + ")"
endglobal

global !p
def split_it(t):
	"function to convert print statements to logging statements"
	split=t.split(',')
	st='lg.info('
	for idx,var in enumerate(split):
		if idx==0:
			if '"' in var or "'" in var:
				var=var[:-1] + ' "'
				st=st+var+" "
			else:
				st=st+"str(" + var+ ")"
		else:
			if '"' in var or "'" in var:
				var=var[:-1] + ' "'
				st=st+"+"+var+" "
			else:
				st=st+"+"+"str(" + var +")"
	st=st+")"
	return st
endglobal


snippet im "Import" b
import $1`!p snip.rv=complete(t[1], ['matplotlib', 'pandas as pd',\
             'numpy as np', 'datetime as dt', 'logging as lg', 'matplotlib.pyplot as plt'])`
endsnippet

snippet fname "current_file_name" b
`!p snip.rv=os.path.basename(fn)`
endsnippet

snippet logit "change print statement to logger" 
`!p snip.rv=split_it(snip.v.text)`
endsnippet

snippet moo "change print statement to logger" b!
`!p snip.rv=snip.v.text`
endsnippet

snippet r
'~/hdrive/repos/cms_analysis/'
endsnippet

snippet sa
'~/hdrive/repos/swissarmy/'
endsnippet

#CHRIS'
snippet log
lg.info("${1:msg}: " + str(${2:non-string}))
endsnippet


snippet timeitcomplicated
#this gets put in a bash script
#see: https://docs.python.org/2/library/timeit.html
#and one of the later answers from here:
#http://stackoverflow.com/questions/8220801/how-to-use-timeit-module

SETUP="
#body python code

def some_function(argument):
	pass
"

# where n is the number of loops (it will self-optimise if left out)
python -m timeit -n 5 -s "$SETUP" "some_function(argument)" 
endsnippet


snippet timeit
start=time.time()
#insert timed code here
finish=time.time()
lg.info("time for ${0:msg}: %s",str(finish-start))
endsnippet

snippet memoryuse
#option 1
#function from http://stackoverflow.com/questions/897941/python-equivalent-of-phps-memory-get-usage
def memory_usage():
    """Memory usage of the current process in kilobytes."""
    status = None
    result = {'peak': 0, 'rss': 0}
    try:
        # This will only work on systems with a /proc file system (like Linux).
        status = open('/proc/self/status')
        for line in status:
            parts = line.split()
            key = parts[0][2:-1].lower()
            if key in result:
                result[key] = int(parts[1])/1024
    finally:
        if status is not None:
            status.close()
    return result

print 'mem use',memory_usage()

#option 2
import resource

#import gc

def func(x, y):
    return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2

grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]
points = np.random.rand(1000, 2)
values = func(points[:,0], points[:,1])

print 'py version',sys.version_info
print 'scipy version',scipy.__version__
print 'numpy version',np.__version__
loops=int(sys.argv[1])

for t in xrange(loops):
    griddata(points, values, (grid_x, grid_y), method='nearest')
    griddata(points, values, (grid_x, grid_y), method='linear')
    griddata(points, values, (grid_x, grid_y), method='cubic')
    #gc.collect()

print 'mem use', resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024
endsnippet

snippet base
os.path.basename(${1:insert_path_to_file})
endsnippet

snippet fout
import contextlib as ctx
with ctx.closing(open(${1:ofol}+${2:'ofile_name.txt'},'w')) as handle:
     handle.write("string to write"+"\n")
endsnippet

snippet collections
import collections
plot_dict=collections.OrderedDict()
endsnippet


snippet docopt
#see: https://github.com/docopt/docopt
#round brackets mean required square are optional

#download docopt from...
#https://raw.githubusercontent.com/docopt/docopt/master/docopt.py

`!p
import inspect,os
docopt_path=os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))+'/docopt.py'
#snip.rv=docopt_path
if not os.path.isfile(docopt_path):
	import urllib
	urllib.urlretrieve("https://raw.githubusercontent.com/docopt/docopt/master/docopt.py",\
	filename=docopt_path)
	#ret='downloaded docopt'
#else:
	#ret='did not download docopt'
#snip.rv=ret
`
"""
${1:Docstring for file}

Usage:
`!p
snip.rv='    '+snip.fn
` -h
`!p
snip.rv='    '+snip.fn
` ( ${2:first_argument} | ${4:second_argument} ) 
Options:
    -h,--help          : show this help message
    $2,--${3:Long_version_first_agument}           : optional argument
    $4                 : mandatory argument (capitals or angled brackets)
"""
from docopt import docopt
arguments = docopt(__doc__)
endsnippet


snippet parser
import argparse
parser = argparse.ArgumentParser(description='Parser for ${1:msg}.',\
epilog='')
parser.add_argument("${2:arg}",help="mandatory argument $2 is: ${3:msg}")
parser.add_argument("${4:arg}",help="mandatory argument $4 is: ${5:msg}")
parser.add_argument("-${6:shortarg}","--${7:longarg}",help="optional argument \
$7 for ${8:msg}.",action="store")
args=parser.parse_args()
lg.info("$2 is: "+str(args.$2))
lg.info("$4 is: "+str(args.$4))
if args.$2!=None:
	pass
if args.$4!=None:
	pass
if args.$7==None:
	lg.info("$7 was not given.")
else:
	lg.info("$7 is: "+args.$7)
endsnippet

snippet hackit
import subprocess 
path=['/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/',\
	'/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf2/',\
	'/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf3/']
boundingbox=['118 130 -37 -31','120 130 -37 -31']

#with ctx.closing(open('./go.sh','w')) as handle:
for p in path:
	for bb in boundingbox:
		do="python cms_diagnostics.py " + p + " " + "-bndbox '" + bb + "' &"
		print p,bb
		print ''
		print do
		subprocess.call(do,shell=True)

#subprocess.call('chmod +x ./go.sh',shell=True)
endsnippet

snippet interpolate 
import numpy as np
import scipy.interpolate

old_grid_data=np.random.rand(4,3)

#old grid dim
loni=np.array([109.94999695, 110.05000305, 110.15000153])
depi=np.array([3.04677272, 9.45404911, 16.36396599, 23.89871025])

#new grid dim
lon=np.arange(110.,110.3,.1) #NB: 110.2 outside of convex hull of old so will produce nan
depth=np.array([3.1,9,16,23])

#create mesh
X, Y = np.meshgrid(loni, depi)
XI, YI = np.meshgrid(lon,depth)

#interp
new_grid=scipy.interpolate.griddata((X.flatten(),Y.flatten()),old_grid_data.flatten() , (XI,YI),method='cubic')

print "this is original"
print old_grid_data.reshape(4,3)
print ""
print "this is interp' by cubic"
print new_grid

print
print "this is diff"
print new_grid-old_grid_data.reshape(4,3)
endsnippet


snippet mkdir
def mkdir(p):
    """make directory of path that is passed"""
    try:
       os.makedirs(p)
       lg.info("output folder: "+p+ " does not exist, we will make one.")
    except OSError as exc: # Python >2.5
       import errno
       if exc.errno == errno.EEXIST and os.path.isdir(p):
          pass
       else: raise
endsnippet

snippet updir
def updir(dir_name,num):
    """
    Function that takes a path and returns the next level up

    Parameters
    ----------
    dir_name: path (string)
    num: number of levels to go up

    Returns
    -------

    Example
    --------
    >>> path=\
    >>> '/srv/ccrc/data32/z3457920/leeuwincurrent3/'
    >>> moo=updir(path,1)
    >>> print moo
    >>> In [4]: moo
    >>> Out[4]: '/srv/ccrc/data32/z3457920/'
    """
    import os
    upd=dir_name
    for n in range(num):
        upd=os.path.abspath(os.path.join(upd, os.pardir))
    return upd+'/'
endsnippet


snippet ncimulti_core
"""
File docstring
#NB probably easier to use docopt snippet here!

The following modules are required to run on NCI:
module purge
module use ~access/modules
module load pythonlib/netCDF4
module load pythonlib/matplotlib
module load pythonlib/six

Usage:
    interpolate_erai.py -h
    interpolate_erai.py ( -p | FILE_PATH )
Options:
    -h,--help          : show this help message
    -p,--pbs           : create pbs files on nci
    FILE_PATH          : path to ERAI parent grid nest file
"""

import logging as lg
import os,inspect

pathfile = os.path.dirname(os.path.realpath(__file__)) 
#sys.path.insert(1,os.path.dirname(pathfile)+'/')
sys.path.insert(1,pathfile+'/')

from cb2logger import *
import contextlib as ctx
from docopt import docopt

arguments = docopt(__doc__)

pbsheader=\
"""
#!/bin/bash
#PBS -P e14
#PBS -q normal
#PBS -l wd
#PBS -l ncpus=1,mem=10Gb,walltime=07:00:00 

#insert code here, e.g.
"""

def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in xrange(0, len(l), n):
        yield list(l[i:i+n])

def mkdir(p):
    """make directory of path that is passed"""
    try:
       os.makedirs(p)
       lg.info("output folder: "+p+ " does not exist, we will make one.")
    except OSError as exc: # Python >2.5
       import errno
       if exc.errno == errno.EEXIST and os.path.isdir(p):
          pass
       else: raise

if __name__ == "__main__":                                     #are we being run directly?
    LogStart('',fout=False)

    ##########
    #  init  #
    ##########
    
    #for nci
    path_to_interp_files='/g/data1/e14/cyb561/cb_tempa/nemo_cordex24_AGRIF/'

    ##########
    #  init  #
    ##########

    ######################
    #  multicore on NCI  #
    ######################

    path_to_pbs='/g/data1/e14/cyb561/cb_tempa/nemo_cordex24_AGRIF/'+'pbs/'
    mkdir(path_to_pbs)

    if arguments['--pbs']:
        ifiles=sorted(glob.glob(path_to_interp_files + 'ERAI*.nc' ))
        assert(ifiles!=[]),"glob didn't find anything!"

        cnt=0
        for fchunk in chunks(ifiles,3):
            with ctx.closing(open(path_to_pbs+str(cnt).zfill(5)+'ERAI_nest_interp'+'.sh','w')) as handle:
                 handle.write(pbsheader+"\n")

                 handle.write("module purge" + "\n")
                 handle.write("module use ~access/modules" + "\n")
                 handle.write("module load pythonlib/netCDF4" + "\n")
                 handle.write("module load pythonlib/matplotlib" + "\n")
                 handle.write("module load pythonlib/six" + "\n")
                 handle.write("" + "\n")
                 
                 for f in fchunk:
                     handle.write("python "+\
                             os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))+"/"+\
                             "interpolate_erai.py "+ f+"\n")
                 
                 handle.write(" "+"\n")

            cnt+=1

        ifiles=sorted(glob.glob(path_to_pbs+ '*ERAI*.sh' ))
        assert(ifiles!=[]),"glob didn't find anything!"
        with ctx.closing(open(path_to_pbs+'runmetosubmit.sh','w')) as handle:
			 handle.write("set -x" + "\n")
			 for f in ifiles:
				 handle.write("qsub " +f+ "\n")
        subprocess.call('chmod +x ' +path_to_pbs+'runmetosubmit.sh',shell=True)

        #import multiprocessing
        #pool=multiprocessing.Pool(processes=2)
        #r=pool.map(main,ifiles[0:2])
        #pool.close()

    ##################
    #  Do the work!  #
    ##################

    if arguments['FILE_PATH'] is not None:
        main(arguments['FILE_PATH'])

    lg.info('')
    #localtime = time.asctime( time.localtime(time.time()) )
    #lg.info("Local current time : "+ str(localtime))
    lg.info('SCRIPT ended')
endsnippet

snippet multi_core
def multi_sh(s_name,args_one):
    """function for an embarrasingly parralel job in which we want to use many cores
    
    :s_name: name of script
    :args_one: list containing argument to send to script
    :returns: s_name + '.sh' script.

    Notes
    -------
    

    Example
    --------
    >>> #to call multi_sh() ...
    >>> s_name='cms_diagnostics.py'
    >>> args_one=\
    >>> ["'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdwesternboundary02/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthernIO_01/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_itf_01/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdnorthern_itf_02/output/pandasHDF/'",\
    >>> "'/srv/ccrc/data32/z3457920/leeuwincurrent3/expt_lc_fwdeasternboundary01/output/pandasHDF/'"]
    >>> multi_sh(s_name,args_one)

    >>> #to put in script
    >>> import sys
    >>> ifile=sys.argv[1]
    >>> lg.info('Working folder: ' + ifile)
    """
    import contextlib as ctx
    import subprocess 
    f_name=s_name[:-3]+'.sh'
    lg.info("Creating multi-core script for: " + f_name)
    with ctx.closing(open('./' + f_name,'w')) as handle:
        for arg in args_one:
            do="python " + s_name +" " + arg+" &"
            lg.info("Writing: " + do)
            #subprocess.call(do,shell=True)
            handle.write(do+"\n")

    subprocess.call('chmod +x ' + f_name,shell=True)
    return
endsnippet

snippet assertf
assert(os.path.exists(${1:variable_to_file_path})),"can't find files ${2:file_discription}"
endsnippet

snippet catch
if ${1:msg}:
	lg.error("${2:msg}: " + str(${3:non-string}))
	sys.exit("Okay, shit went bad, now exit.")
endsnippet


snippet catchg
#error trap for globbing...
if ${1:msg}==[]:
	lg.error("Globbing returned nothing!")
	sys.exit("Okay, shit went bad, now exit.")
endsnippet
		

snippet loopme
for $1 in $2:
    ${VISUAL}
endsnippet

snippet s
str(${VISUAL:object to convert to string})
endsnippet

snippet w
${1:function you want to call}(${VISUAL:object that will be wrapped})
endsnippet

snippet nfo
lg.info("${VISUAL:object to put in}")
endsnippet

snippet confirm
confirm = raw_input("Please confirm you're happy with the ...")
if confirm=='y':
    #do something!
	pass
elif confirm=='n':
   sys.exit("Quitting b/c you said you weren't happy with the slice.")
else:
   sys.exit("Quitting b/c you didn't answer yes ('y')  or no ('n').")
endsnippet

snippet clobber
#a clobber check here
try:
    os.remove(${1:file_path})
    lg.info("File: " +os.path.basename($1) + " already exists, clobbering!")
except OSError:
    pass 
endsnippet

snippet months
plt.xlim(0.8, 12.2)
labels=['J','F','M','A','M','J','J','A','S','O','N','D']
labels=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']
ax1.set_xlim(0.8, 12.2)
ax1.set_xticklabels(labels)
endsnippet

snippet regex
#really handonline regex finder: https://regex101.com/#python
import re
test_string='cordex24REALNONZ500-ERAI01_1d_19890101_19891231_grid_T_2D.nc'
exp = re.search(r'[0-9]{8}_[0-9]{8}', test_string) ; exp=exp.group()
print exp
endsnippet

# New Class
snippet cl
class ${1:ClassName}(${2:object}):
	"""
	${3:docstring for $1}.

	Parameters
	----------
	$4: 

	Returns
	-------
	
	Notes
	-------
	

	Example
	--------
	>>> 
	>>> 
	"""
	def __init__(self, ${4:arg}):
		${5:super($1, self).__init__()}
		self.$4 = $4
		${0}
endsnippet

# New Function
snippet de
def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
	"""
	${3:docstring for $1}.

	Parameters
	----------
	$4: 

	Returns
	-------
	
	Notes
	-------
	

	Example
	--------
	>>> 
	>>> 
	"""
	${0}
endsnippet

#pandas
snippet savehdf_append
efile = ${1:variable for export path} + ${2:name of exported hdf}+'_table'+ '.h5'
store = pd.HDFStore(efile,complevel=9, complib='blosc')
store.append('DF',DF,data_columns = ${3:list of columns that will be data columns}) #querable columns or dc take more space and are slower
store.close()
endsnippet


snippet savehdf_put
efile = ${1:variable for export path} +\
		${2:name of exported hdf} +\
        '_table'+ '.h5'

#a clobber check here
try:
    os.remove(efile)
    lg.info("HDFStore already existed, clobbering!")
except OSError:
    pass 

#Due to Pandas 'TypeError' had to use put rather than append...
store = pd.HDFStore(efile,complevel=9, complib='blosc')
store.put('$3',${3:name of dataframe})
store.close()
endsnippet

snippet toypanda
import itertools
import pandas as pd
import numpy as np
def expand_grid(data_dict):
    rows = itertools.product(*data_dict.values())
    return pd.DataFrame.from_records(rows, columns=data_dict.keys())


df = expand_grid(
    {'height': [60, 70],
     'weight': [100, 140, 180],
     'sex': ['Male', 'Female']}
    )

df2 = pd.DataFrame(
        {u'stratifying_var': np.random.uniform(0, 100, 20),
         u'price': np.random.normal(100, 5, 20)}
    )
endsnippet


snippet toypandamerge
#Doing join/merge of DF's that are different sizes...
one=pd.DataFrame({"year":[1992,2003,2014],"blah":[231,1232,1212],"parnum":[1,2,3]})
two=pd.DataFrame({"seconds":[20,40,20,60,60,60],"garbage":[204,430,240,-60,604,603],"parnum":[1,1,2,3,3,3]})
two.merge(one[['year','parnum']],on='parnum')
endsnippet

snippet loadtoy
import pandas as pd
import numpy as np
file='/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/'
file='/srv/ccrc/data32/z3457920/leeuwincurrent2/expt_lc_fwdcore01/output/pandasHDF/toyhdf/'
file='/home/z3457920/hdrive/repos/cms_analysis/fwdcore_toyhdf/traj_file_05_table.h5'
dataframe=pd.HDFStore(file)
df=dataframe.select('DF')
endsnippet


snippet toymaskedarray 
import numpy as np
mask=[[False,True,False], \
     [False,False,False], \
     [False,False,True], \
     [False,True,False]]
old=np.ma.MaskedArray(np.random.rand(4,3),mask=mask)
new=np.ma.MaskedArray(np.random.rand(4,3),mask=mask)
endsnippet

snippet loadnetcdf
from netCDF4 import Dataset
infile='/path/to/netcdf4/file.nc'
ifile=Dataset(infile, 'r')
varone=ifile.variables['']
endsnippet


snippet loadhdf
import pandas as pd
file='path/to/hdfstore.h5'
dataframe=pd.HDFStore(file)
df=dataframe.select('DF')
endsnippet


snippet glob
import glob
ifiles=sorted(glob.glob(${1:varpath to glob} + ${2:string to glob} ))
assert(ifiles!=[]),"glob didn't find anything!"
endsnippet

snippet pd
import pandas as pd
endsnippet

snippet rounddf
slice['latitude']=np.round(slice['latitude']/.1)*.1     
endsnippet


snippet pickle
#Save a dictionary into a pickle file.
import pickle
favorite_color = { "lion": "yellow", "kitty": "red" }
pickle.dump( favorite_color, open( "save.p", "wb" ) )

# Load the dictionary back from the pickle file.
favorite_color = pickle.load( open( "save.p", "rb" ) )
# favorite_color is now { "lion": "yellow", "kitty": "red" }
endsnippet

snippet sor
ifiles=sorted(glob.glob(path + '*' ))
endsnippet

#quick import commands
snippet plt
import matplotlib.pyplot as plt
endsnippet

snippet np
import numpy as np
endsnippet

###########################################################################
#                               MATPLOTLIB                                #
###########################################################################

snippet splot
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
plt.show()
endsnippet

snippet plthack
def ${1:function_name}(output_opt):
    """
	This function ($1) is designed to ${2:function_doc_string}
    """
	${0:code to plot}
    if output_opt=='':
        plt.show()
    else:
        plt.savefig(output_opt+'$1.png',dpi=300)
        #plt.savefig(output_opt+'$1.pdf',format='pdf')
endsnippet

snippet scatter
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:#code to plot}
scat=ax.scatter(whole_trajectory['longitude'].tolist(),whole_trajectory['latitude'].tolist(),c=whole_trajectory.depth_m,lw=0,s=3,marker='o',vmin=0,vmax=300)
ax.scatter(whole_trajectory.iloc[-1]['longitude'].tolist(),whole_trajectory.iloc[-1]['latitude'].tolist(),color='k',alpha=1,marker='D',s=32*4)
ax.set_title(str(incoming_df['parnum'])+' start is plus' + ' end is diamond')
fig.colorbar(scat,ticks=np.arange(0,5900,50),orientation='horizontal')
ax.set_title('${1:msg}')
ax.set_xlabel('${2:msg}')
ax.set_ylabel('${3:msg}')
#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')
plt.show()
endsnippet

snippet plot
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
ax.set_title('${1:msg}')
ax.set_xlabel('${2:msg}')
ax.set_ylabel('${3:msg}')
#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')
plt.show()
endsnippet

snippet savefig
fig.savefig('./.png',dpi=300)
fig.savefig('./.pdf',format='pdf')
endsnippet

snippet snsplot
import seaborn as sns
import itertools
#sns.set(style="whitegrid")
sns.axes_style('darkgrid')
#sns.set_style("ticks")
#sns.set_palette("deep", desat=.6)
sns.set_style("darkgrid", {"grid.linewidth": .5, "axes.facecolor": ".9"})
sym=itertools.cycle(['v','o','^','s','D'])
plt.close('all')
fig=plt.figure()
ax=fig.add_subplot(1, 1,1)
${0:code to plot}
ax.plot(foob.index,foob['transport'], linestyle='--',marker=sym.next(),label=cookie)
plt.show()

#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')

## Now add the legend with some customizations.
#legend = ax.legend(loc='upper right', shadow=True)
#
## The frame is matplotlib.patches.Rectangle instance surrounding the legend.
#frame = legend.get_frame()
#frame.set_facecolor('0.90')
endsnippet

snippet snsplotcomplicated
import seaborn as sns
import itertools
#sns.set(style="whitegrid")
sns.axes_style('darkgrid')
#sns.set_style("ticks")
#sns.set_palette("deep", desat=.6)
sns.set_style("darkgrid", {"grid.linewidth": .5, "axes.facecolor": ".9"})
sym=itertools.cycle(['v','o','^','s','D'])
plt.close('all')
fig=plt.figure()
#fig.set_size_inches(20,12.5)
ax1=fig.add_subplot(2, 1,1)
ax2=fig.add_subplot(2, 1,2)

${0:code to plot}
ax1.plot(foob.index,foob['transport'], linestyle='--',marker=sym.next(),label=cookie)

ax2.set_title('Month--crossing location')
ax2.set_xlabel('month')
ax2.set_ylabel('transport')

#note you can specify axis!
sns.barplot(whole_mean.pathway,whole_mean.transport,ax=ax2)
plt.show()


#fig.savefig('./.png',dpi=300)
#fig.savefig('./.pdf',format='pdf')

## Now add the legend with some customizations.
#legend = ax.legend(loc='upper right', shadow=True)
#
## The frame is matplotlib.patches.Rectangle instance surrounding the legend.
#frame = legend.get_frame()
#frame.set_facecolor('0.90')
endsnippet

snippet figsize
#width then height
fig=plt.figure(figsize=(20.0,9.0))
endsnippet

snippet gridspecplot
from matplotlib import gridspec
import matplotlib.pyplot as plt
#set up for gridspec plot...
plt.close('all')
#width then height
fig=plt.figure(figsize=(20.0,9.0))
#the other option
#fig.set_size_inches(7.5,15.5)

#if you want to use seaborn too...
import seaborn as sns
sns.set(style="whitegrid")
sns.set_style("ticks")
gs = gridspec.GridSpec(5, 2,width_ratios=[5,1],hspace=.225,wspace=0.065)

#contour plot
ax0 = plt.subplot(gs[0,0])
#ax0.set_title('Crossing at 30 S')
ax0.set_ylabel('Transport (Sv)')

ax1 = plt.subplot(gs[0,1])

ax2 = plt.subplot(gs[1,0], sharex=ax0)
ax2.set_title('Subplot title')
ax2.set_ylabel('Transport (Sv)')

# make some labels invisible
plt.setp(ax1.get_yticklabels()+ax1.get_xticklabels()+\
         ax0.get_xticklabels()+\
         ax2.get_yticklabels(),\
                 visible=False)

#turn on tight layout for gridspec, see more options here:
#http://matplotlib.org/users/tight_layout_guide.html
#couldn't actually get this to work... these options: pad=0.4, w_pad=0.5,
#h_pad=1.0
gs.tight_layout(fig)

# sub-panel enumerations
plt.figtext(0.1, 0.92,  'a)',clip_on=False,color='black',size=22)
plt.figtext(0.1, 0.77,  'b)',clip_on=False,color='black',size=22)
plt.show()
endsnippet


snippet title
ax.set_title('${1:Title}')
endsnippet

snippet xlab
ax.set_xlabel('${1:xlabel}')
endsnippet

snippet ylab
ax.set_xlabel('${1:ylabel}')
endsnippet

snippet xlim
#ax.set_xlim([-1,5])
endsnippet

snippet ylim
#ax.set_ylim([-10,10])
endsnippet

snippet lines
#these use axes coords!
#ax.axhline(y=0.2,xmin=0,xmax=3,c="blue",linewidth=3,zorder=0)
#ax.axhline(y=-8,xmin=0,xmax=0.5,c="blue",linewidth=3)
#ax.axhline(y=-5, xmin=0, xmax=0.5,c="red",linewidth=3,zorder=0)

# horizontal line
ax.hlines(y=-8.5, xmin=90, xmax=114,linewidth=3, color='red', zorder=1)
ax.hlines(y=-8.5, xmin=114, xmax=140,linewidth=3, color='purple', zorder=1)

# vertical line
ax.vlines(x=90.1, ymin=-49, ymax=-8.5,linewidth=3, color='blue', zorder=1)
ax.vlines(x=142.5, ymin=-11, ymax=-9,linewidth=3, color='sienna', zorder=1)
endsnippet

snippet globalsavefig
##file for importing global settings
from p_global_settings import *

if plottype=='png':
	plt.savefig(global_plot_outfol+'${1:output_file_name}.png',dpi=300)
elif plottype=='pdf':
	plt.savefig(global_plot_outfol+'$1.pdf')
elif plottype=='both':
	plt.savefig(global_plot_outfol+'$1.png',dpi=300)
	plt.savefig(global_plot_outfol+'$1.pdf')
endsnippet


#stolen from:
#http://bazaar.launchpad.net/~sirver/ultisnips/trunk/view/head:/UltiSnips/python.snippets
###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
# encoding: utf-8
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == '__main__':
	${1:main()}$0
endsnippet


##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2

def get_args(arglist):
    args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
    args = [arg for arg in args if arg and arg != "self"]

    return args


def get_style(snip):
    style = snip.opt("g:ultisnips_python_style", "normal")

    if    style == "doxygen": return DOXYGEN
    else: return NORMAL


def format_arg(arg, style):
    if style == DOXYGEN:
        return "@param %s @todo" % arg
    elif style == NORMAL:
        return ":%s: @todo" % arg


def format_return(style):
    if style == DOXYGEN:
        return "@return: @todo"
    elif style == NORMAL:
        return ":returns: @todo"


def write_docstring_args(args, snip):
    if not args:
        snip.rv += ' """'
        return

    snip += ""

    style = get_style(snip)

    for arg in args:
        snip += format_arg(arg, style)


def write_init_body(args, parents, snip):
    parents = [p.strip() for p in parents.split(",")]
    parents = [p for p in parents if p != 'object']

    for p in parents:
        snip += p + ".__init__(self)"

    if parents:
        snip += ""

    for arg in args:
        snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
    args = ['"%s"' % arg for arg in args]
    snip += '__slots__ = (%s,)' % ', '.join(args)

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'


snip += ""
write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""
	`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args: snip += '"""'

snip += ""
write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}


def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}


def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}


def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}


def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}


def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}


def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

snippet def "function with docstrings" b
def ${1:function}(`!p
if snip.indent:
   snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	"""${4:@todo: Docstring for $1}`!p
snip.rv = ""
snip >> 1

args = get_args(t[2])
if args:
   write_docstring_args(args, snip)

style = get_style(snip)
snip += format_return(style)
snip += '"""' `

	${0:pass}
endsnippet


# doesn't expand when there is a word in front
snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet from "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet


##############
# PROPERTIES #
##############
snippet roprop "Read Only Property" b
@property
def ${1:property}(self):
	${2:return self._$1}$0
endsnippet

snippet rwprop "Read write property" b
def ${1:property}():
	${2/.+/(?0:""")/}${2:The RW property $1}${2/.+/(?0:"""\n		)/}def fget(self):
		return self._$1$0
	def fset(self, value):
		self._$1 = value
	return locals()
$1 = property(**$1())
endsnippet


##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
endsnippet

snippet try "Try / Except / Else" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet try "Try / Except / Finally" b
try:
	${1:pass}
except ${2:Exception}, ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet try "Try / Except / Else / Finally" b
try:
	${1:pass}
except${2: ${3:Exception}, ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


#####################
# Assertions & Tests #
#####################

snippet ae "Assert equal" b
self.assertEqual(${1:first},${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${0:exp})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:expression})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:first},${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:func}${3/.+/, /}${3:arguments})
endsnippet


snippet testcase "pyunit testcase" b
class Test${1:Class}(${2:unittest.TestCase}):
	"""${3:Test case docstring}"""

	def setUp(self):
		${3:pass}

	def tearDown(self):
		${4:pass}

	def test_${5:name}(self):
		${6:pass}
endsnippet

# vim:ft=snippets:
